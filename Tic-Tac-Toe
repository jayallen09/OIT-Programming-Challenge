#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>

using namespace std;

// Function prints current state of the board
// It iterates over each cell of the grid
// for each row prints the cell values separated by vertical bars
void displayGrid(const vector<vector<char>>& grid) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            cout << grid[i][j];
            if (j < 2) cout << "|";
        }
        cout << endl;
        if (i < 2) cout << "-----" << endl;
    }
    cout << endl;
}

// Function to check if a player has won the game by checking the rows, columns, and diagonals
bool checkWin(const vector<vector<char>>& grid, char mark) {
    // Iterates through the grid and Check rows, columns, and diagonals
    for (int i = 0; i < 3; i++) {
        if (grid[i][0] == mark && grid[i][1] == mark && grid[i][2] == mark) return true;
        if (grid[0][i] == mark && grid[1][i] == mark && grid[2][i] == mark) return true;
    }
    if (grid[0][0] == mark && grid[1][1] == mark && grid[2][2] == mark) return true;
    if (grid[0][2] == mark && grid[1][1] == mark && grid[2][0] == mark) return true;
    return false;
    // If any condition is met it returns true and that indicates a win. Otherwise its false and no win.
}

// Function to check for a draw
// Checks to see if all cells are filled. If they are all filled and there is no winner. then it returns true indicating a draw.
bool checkDraw(const vector<vector<char>>& grid) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (grid[i][j] == ' ') return false;
        }
    }
    return true;
}

// Function for the computer to make a move
// Generates random row and colums and keeps generating until if finds an empty cell. Once it does, it places an 'O' in that cell.
void computerMove(vector<vector<char>>& grid) {
    int row, col;
    do {
        row = rand() % 3;
        col = rand() % 3;
    } 
     while (grid[row][col] != ' ');
        grid[row][col] = 'O';
}

// Function for the user's move
// Prompts the user to enter a row and column number. They must be between 1 and 3. If the cell is already occupied, it prompts the user to enter another row and column.
// If the move is valid, it places an 'X' in that cell and breaks out of the loop.
void userMove(vector<vector<char>>& grid) {
    int row, col;
    while (true) {
        cout << "Enter your move (row and column, Type the row and hit enter. Then type the column and hit enter. Numbers 1-3 for both): ";
        cin >> row >> col;
        if (row >= 1 && row <= 3 && col >= 1 && col <= 3 && grid[row - 1][col - 1] == ' ') {
            grid[row - 1][col - 1] = 'X';
            break;
        } 
        else {
            cout << "Invalid move. Try again." << endl;
        }
    }
}



// The code kept using the same sequence over again so I seeded the random number generator with the current time. 
// I used a do-while loop so that the game could be played multiple times.
// Then made it so that after every turn, the displayGrid function is called to show the current state of the board.
// After every move it chekcs for a win or a draw.

int main() {
    srand(static_cast<unsigned int>(time(0)));
    string response;
    bool userFirst;

    do {
        vector<vector<char>> grid(3, vector<char>(3, ' '));

        cout << "Welcome to Tic-Tac-Toe\n" << endl;
        cout << "User is X and Computer is O\n" << endl;
        cout << "To start off, tell me if you want to go first or second. Type 'first' to go first or 'second' to go second." << endl;

        while (response != "first" && response != "second") {
            cin >> response;
            if (response == "first") {
                userFirst = true;
                cout << "You will go first" << endl;
            } 
            else if (response == "second") {
                userFirst = false;
                cout << "You will go second" << endl;
            } 
            else {
                cout << "Invalid response. Please enter a valid input." << endl;
            }
        }

        bool gameOver = false;
        while (!gameOver) {
            displayGrid(grid);

            if (userFirst) {
                userMove(grid);
                displayGrid(grid);
                if (checkWin(grid, 'X')) {
                    cout << "Congratulations! You win!" << endl;
                    gameOver = true;
                } 
                else if (checkDraw(grid)) {
                    cout << "It's a draw!" << endl;
                    gameOver = true;
                } 
                else {
                    computerMove(grid);
                    displayGrid(grid);
                    if (checkWin(grid, 'O')) {
                        cout << "Computer wins!" << endl;
                        gameOver = true;
                    } 
                    else if (checkDraw(grid)) {
                        cout << "It's a draw!" << endl;
                        gameOver = true;
                    }
                }
            } 
            else {
                computerMove(grid);
                displayGrid(grid);
                if (checkWin(grid, 'O')) {
                    cout << "Computer wins!" << endl;
                    gameOver = true;
                } 
                else if (checkDraw(grid)) {
                    cout << "It's a draw!" << endl;
                    gameOver = true;
                } 
                else {
                    userMove(grid);
                    displayGrid(grid);
                    if (checkWin(grid, 'X')) {
                        cout << "Congratulations! You win!" << endl;
                        gameOver = true;
                    } 
                    else if (checkDraw(grid)) {
                        cout << "It's a draw!" << endl;
                        gameOver = true;
                    }
                }
            }
        }

        cout << "Do you want to play again? (yes/no): ";
        cin >> response;
    } 
        while (response == "yes");

    cout << "Thank you for playing! Goodbye!" << endl;
    return 0;
}
